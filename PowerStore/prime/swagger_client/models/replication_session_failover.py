# coding: utf-8

"""
    PowerStore REST API

    Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )  # noqa: E501

    OpenAPI spec version: 3.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from prime.swagger_client.configuration import Configuration


class ReplicationSessionFailover(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'is_planned': 'bool',
        'reverse': 'bool',
        'use_test_copy': 'bool',
        'failover_snapshot_id': 'str',
        'force': 'bool'
    }

    attribute_map = {
        'is_planned': 'is_planned',
        'reverse': 'reverse',
        'use_test_copy': 'use_test_copy',
        'failover_snapshot_id': 'failover_snapshot_id',
        'force': 'force'
    }

    def __init__(self, is_planned=True, reverse=False, use_test_copy=False, failover_snapshot_id=None, force=False, _configuration=None):  # noqa: E501
        """ReplicationSessionFailover - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration

        self._is_planned = None
        self._reverse = None
        self._use_test_copy = None
        self._failover_snapshot_id = None
        self._force = None
        self.discriminator = None

        if is_planned is not None:
            self.is_planned = is_planned
        if reverse is not None:
            self.reverse = reverse
        if use_test_copy is not None:
            self.use_test_copy = use_test_copy
        if failover_snapshot_id is not None:
            self.failover_snapshot_id = failover_snapshot_id
        if force is not None:
            self.force = force

    @property
    def is_planned(self):
        """Gets the is_planned of this ReplicationSessionFailover.  # noqa: E501

        Indicates whether the replication session failover is planned or unplanned. For planned failovers, the value is true. For unplanned failovers, the value is false.   # noqa: E501

        :return: The is_planned of this ReplicationSessionFailover.  # noqa: E501
        :rtype: bool
        """
        return self._is_planned

    @is_planned.setter
    def is_planned(self, is_planned):
        """Sets the is_planned of this ReplicationSessionFailover.

        Indicates whether the replication session failover is planned or unplanned. For planned failovers, the value is true. For unplanned failovers, the value is false.   # noqa: E501

        :param is_planned: The is_planned of this ReplicationSessionFailover.  # noqa: E501
        :type: bool
        """

        self._is_planned = is_planned

    @property
    def reverse(self):
        """Gets the reverse of this ReplicationSessionFailover.  # noqa: E501

        Indicates whether the system is auto-reprotected. Auto-reprotect is combination of failover and reprotect.  This is only allowed when issuing a planned failover.   # noqa: E501

        :return: The reverse of this ReplicationSessionFailover.  # noqa: E501
        :rtype: bool
        """
        return self._reverse

    @reverse.setter
    def reverse(self, reverse):
        """Sets the reverse of this ReplicationSessionFailover.

        Indicates whether the system is auto-reprotected. Auto-reprotect is combination of failover and reprotect.  This is only allowed when issuing a planned failover.   # noqa: E501

        :param reverse: The reverse of this ReplicationSessionFailover.  # noqa: E501
        :type: bool
        """

        self._reverse = reverse

    @property
    def use_test_copy(self):
        """Gets the use_test_copy of this ReplicationSessionFailover.  # noqa: E501

        When a failover test is in progress and an unplanned failover needs to be started, this flag must be set to true. Setting this flag to true will keep the destination resources' data as is before starting the unplanned failover. Please stop the failover test first if you do not wish to keep the test data before starting an unplanned failover.  Was added in version 2.0.0.0.  # noqa: E501

        :return: The use_test_copy of this ReplicationSessionFailover.  # noqa: E501
        :rtype: bool
        """
        return self._use_test_copy

    @use_test_copy.setter
    def use_test_copy(self, use_test_copy):
        """Sets the use_test_copy of this ReplicationSessionFailover.

        When a failover test is in progress and an unplanned failover needs to be started, this flag must be set to true. Setting this flag to true will keep the destination resources' data as is before starting the unplanned failover. Please stop the failover test first if you do not wish to keep the test data before starting an unplanned failover.  Was added in version 2.0.0.0.  # noqa: E501

        :param use_test_copy: The use_test_copy of this ReplicationSessionFailover.  # noqa: E501
        :type: bool
        """

        self._use_test_copy = use_test_copy

    @property
    def failover_snapshot_id(self):
        """Gets the failover_snapshot_id of this ReplicationSessionFailover.  # noqa: E501

        Optional identifier of a snapshot that the destination resource must be restored to as part of an unplanned failover. If a failover_snapshot_id is not specified, the destination will be restored to the last common base snapshot. This identifier is not supported when a failover test is in progress.  Was added in version 2.0.0.0.  # noqa: E501

        :return: The failover_snapshot_id of this ReplicationSessionFailover.  # noqa: E501
        :rtype: str
        """
        return self._failover_snapshot_id

    @failover_snapshot_id.setter
    def failover_snapshot_id(self, failover_snapshot_id):
        """Sets the failover_snapshot_id of this ReplicationSessionFailover.

        Optional identifier of a snapshot that the destination resource must be restored to as part of an unplanned failover. If a failover_snapshot_id is not specified, the destination will be restored to the last common base snapshot. This identifier is not supported when a failover test is in progress.  Was added in version 2.0.0.0.  # noqa: E501

        :param failover_snapshot_id: The failover_snapshot_id of this ReplicationSessionFailover.  # noqa: E501
        :type: str
        """

        self._failover_snapshot_id = failover_snapshot_id

    @property
    def force(self):
        """Gets the force of this ReplicationSessionFailover.  # noqa: E501

        Indicates whether an unplanned failover needs to be performed for a session that is already in a failed over state.   # noqa: E501

        :return: The force of this ReplicationSessionFailover.  # noqa: E501
        :rtype: bool
        """
        return self._force

    @force.setter
    def force(self, force):
        """Sets the force of this ReplicationSessionFailover.

        Indicates whether an unplanned failover needs to be performed for a session that is already in a failed over state.   # noqa: E501

        :param force: The force of this ReplicationSessionFailover.  # noqa: E501
        :type: bool
        """

        self._force = force

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(ReplicationSessionFailover, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ReplicationSessionFailover):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, ReplicationSessionFailover):
            return True

        return self.to_dict() != other.to_dict()
