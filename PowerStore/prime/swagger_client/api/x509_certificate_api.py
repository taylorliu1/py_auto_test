# coding: utf-8

"""
    PowerStore REST API

    Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )  # noqa: E501

    OpenAPI spec version: 3.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from prime.swagger_client.api_client import ApiClient


class X509CertificateApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def x509_certificate_csr_post(self, body, **kwargs):  # noqa: E501
        """Generate CSR  # noqa: E501

        Generate a new certificate signing request. A new X509 Certificate instance will be created to hold the private key and passphrase, whose is_current and is_valid attributes will both be false. Only Management_HTTP, Syslog_HTTP and VASA_HTTP are supported service types. For Management_HTTP serivce, scope must to be provided with value External; any other value will be rejected. Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_csr_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param X509CertificateCsr body: Request body. (required)
        :return: X509CertificateCsrResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.x509_certificate_csr_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.x509_certificate_csr_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def x509_certificate_csr_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Generate CSR  # noqa: E501

        Generate a new certificate signing request. A new X509 Certificate instance will be created to hold the private key and passphrase, whose is_current and is_valid attributes will both be false. Only Management_HTTP, Syslog_HTTP and VASA_HTTP are supported service types. For Management_HTTP serivce, scope must to be provided with value External; any other value will be rejected. Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_csr_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param X509CertificateCsr body: Request body. (required)
        :return: X509CertificateCsrResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method x509_certificate_csr_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `x509_certificate_csr_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/x509_certificate/csr', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='X509CertificateCsrResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def x509_certificate_exchange_post(self, body, **kwargs):  # noqa: E501
        """Exchange Certificates  # noqa: E501

        Exchange certificates between two clusters. Add CA certificates to the trust store of each cluster and assign roles to the client certificates. After this process, certificate-based authentication can be used for communication between clusters. This exchange REST API can only be triggered with service Replication_HTTP.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_exchange_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param X509CertificateExchange body: Request body. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.x509_certificate_exchange_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.x509_certificate_exchange_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def x509_certificate_exchange_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Exchange Certificates  # noqa: E501

        Exchange certificates between two clusters. Add CA certificates to the trust store of each cluster and assign roles to the client certificates. After this process, certificate-based authentication can be used for communication between clusters. This exchange REST API can only be triggered with service Replication_HTTP.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_exchange_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param X509CertificateExchange body: Request body. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method x509_certificate_exchange_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `x509_certificate_exchange_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/x509_certificate/exchange', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def x509_certificate_get(self, **kwargs):  # noqa: E501
        """Collection Query  # noqa: E501

        Query to list X509 Certificates instances.  This resource type collection query does not support filtering, sorting or pagination.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[X509CertificateInstance]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.x509_certificate_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.x509_certificate_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def x509_certificate_get_with_http_info(self, **kwargs):  # noqa: E501
        """Collection Query  # noqa: E501

        Query to list X509 Certificates instances.  This resource type collection query does not support filtering, sorting or pagination.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[X509CertificateInstance]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method x509_certificate_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/x509_certificate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[X509CertificateInstance]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def x509_certificate_id_get(self, id, **kwargs):  # noqa: E501
        """Instance Query  # noqa: E501

        Query a specific X509 Certificate instance.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the X509 Certificate. (required)
        :return: X509CertificateInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.x509_certificate_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.x509_certificate_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def x509_certificate_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Instance Query  # noqa: E501

        Query a specific X509 Certificate instance.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the X509 Certificate. (required)
        :return: X509CertificateInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method x509_certificate_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `x509_certificate_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/x509_certificate/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='X509CertificateInstance',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def x509_certificate_id_patch(self, id, body, **kwargs):  # noqa: E501
        """Modify  # noqa: E501

        Update/modify a X509 Certificate instance by unique identifier. This request may only be used when certificate usage type is server or client certificate. Please note that for Management_HTTP service, is_current must be set to true to avoid losing the management connection to the server. Setting the is_current flag to true on the new certificate will delete any existing current certificate. Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_id_patch(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the X509 Certificate. (required)
        :param X509CertificateModify body: Request body. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.x509_certificate_id_patch_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.x509_certificate_id_patch_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def x509_certificate_id_patch_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Modify  # noqa: E501

        Update/modify a X509 Certificate instance by unique identifier. This request may only be used when certificate usage type is server or client certificate. Please note that for Management_HTTP service, is_current must be set to true to avoid losing the management connection to the server. Setting the is_current flag to true on the new certificate will delete any existing current certificate. Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_id_patch_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the X509 Certificate. (required)
        :param X509CertificateModify body: Request body. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method x509_certificate_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `x509_certificate_id_patch`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `x509_certificate_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/x509_certificate/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def x509_certificate_post(self, body, **kwargs):  # noqa: E501
        """Create  # noqa: E501

        Add/import a new X509 Certificate. When certificate usage type in the request is server or client, private key and passphrase are required. Private key presented in the request should be encrypted in PKCS8 format. For the current release following services are supported - Import_HTTP, LDAP_HTTP, Syslog_HTTP for which the certificate can be imported. CA certificates of type CA_Client_Validation and CA_Server_Validation are supported for all service types. If the imported client/server certificate with is_current flag is set to true and corresponding CA Client Validation or CA Server Validation certificate's is_current flag is not set or updated to true , will cause a loss in connection to the client/server. There can be multiple CA certs for a given service with is_current flag set to true. But for client/server certificates, setting the is_current flag to true on the new certificate will delete the existing current certificate. Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param X509CertificateCreate body: Request body. (required)
        :return: CreateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.x509_certificate_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.x509_certificate_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def x509_certificate_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create  # noqa: E501

        Add/import a new X509 Certificate. When certificate usage type in the request is server or client, private key and passphrase are required. Private key presented in the request should be encrypted in PKCS8 format. For the current release following services are supported - Import_HTTP, LDAP_HTTP, Syslog_HTTP for which the certificate can be imported. CA certificates of type CA_Client_Validation and CA_Server_Validation are supported for all service types. If the imported client/server certificate with is_current flag is set to true and corresponding CA Client Validation or CA Server Validation certificate's is_current flag is not set or updated to true , will cause a loss in connection to the client/server. There can be multiple CA certs for a given service with is_current flag set to true. But for client/server certificates, setting the is_current flag to true on the new certificate will delete the existing current certificate. Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param X509CertificateCreate body: Request body. (required)
        :return: CreateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method x509_certificate_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `x509_certificate_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/x509_certificate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def x509_certificate_reset_certificates_post(self, body, **kwargs):  # noqa: E501
        """Reset certificates by service  # noqa: E501

        Reset x509 certificates for one service to the initial state for the system. This is used to recover system from an invalid certificates or private key for services like VASA provider (VASA_HTTP) when VASA Provider certificates are invalid. This can restore the VASA Provider certificate to a new self-signed certificate, so that VASA Provider can be re-registered with vCenter. This is valid only for the VASA_HTTP service and requires either the Administrator, Security Administrator, or VASA administrator role. Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_reset_certificates_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param X509CertificateResetCertificates body: Request body. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.x509_certificate_reset_certificates_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.x509_certificate_reset_certificates_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def x509_certificate_reset_certificates_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Reset certificates by service  # noqa: E501

        Reset x509 certificates for one service to the initial state for the system. This is used to recover system from an invalid certificates or private key for services like VASA provider (VASA_HTTP) when VASA Provider certificates are invalid. This can restore the VASA Provider certificate to a new self-signed certificate, so that VASA Provider can be re-registered with vCenter. This is valid only for the VASA_HTTP service and requires either the Administrator, Security Administrator, or VASA administrator role. Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.x509_certificate_reset_certificates_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param X509CertificateResetCertificates body: Request body. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method x509_certificate_reset_certificates_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `x509_certificate_reset_certificates_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/x509_certificate/reset_certificates', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
