# coding: utf-8

"""
    PowerStore REST API

    Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )  # noqa: E501

    OpenAPI spec version: 3.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from prime.swagger_client.api_client import ApiClient


class ReplicationSessionApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def replication_session_get(self, **kwargs):  # noqa: E501
        """Collection Query  # noqa: E501

        Query replication sessions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ReplicationSessionInstance]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_session_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.replication_session_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def replication_session_get_with_http_info(self, **kwargs):  # noqa: E501
        """Collection Query  # noqa: E501

        Query replication sessions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ReplicationSessionInstance]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_session_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/replication_session', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReplicationSessionInstance]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_session_id_demote_post(self, id, **kwargs):  # noqa: E501
        """Demote replication session  # noqa: E501

        This is to demote a local resource to make it unavailable. This is used in specific failure scenario where user needs ability to move a preferred side local resource into unavailable state. The local_resource_state property on the session instance will indicate that the local side of the metro session was demoted through user action.  Was added in version 3.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_demote_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  Was added in version 3.0.0.0. (required)
        :param ReplicationSessionDemote body: Parameters to demote a replication session.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_session_id_demote_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_session_id_demote_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_session_id_demote_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Demote replication session  # noqa: E501

        This is to demote a local resource to make it unavailable. This is used in specific failure scenario where user needs ability to move a preferred side local resource into unavailable state. The local_resource_state property on the session instance will indicate that the local side of the metro session was demoted through user action.  Was added in version 3.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_demote_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  Was added in version 3.0.0.0. (required)
        :param ReplicationSessionDemote body: Parameters to demote a replication session.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_session_id_demote_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `replication_session_id_demote_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/replication_session/{id}/demote', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_session_id_failover_post(self, id, **kwargs):  # noqa: E501
        """Failover  # noqa: E501

        Fail over a replication session instance of type Asynchronous. Failing over the replication session changes the role of the destination system. After a failover, the original destination system becomes the source system, and production access is enabled for hosts and applications for recovery. Failovers can be planned or unplanned.     Planned failovers are issued from the source system and are indicated by setting the is_planned parameter to true. When you fail over a replication session from the source system, the destination system is fully synchronized with the source to ensure that there is no data loss. During a planned failover, stop I/O operations for any applications and hosts. If a synchronization error occurs during a planned failover, the replication session enters the System_Paused state. You cannot pause a replication session during a planned failover. The following operations can be performed during planned failover: * Unplanned failover * Delete the replication session by removing the protection policy on the storage resource     Failover (planned or unplanned) cannot be performed when a test failover is in progress.     After a planned failover, the replication session is in an inactive state. You can use the reprotect action to synchronize the destination storage resource, and then resume the replication session. The auto-reprotect feature can also be used after a planned failover by using the reverse parameter, which activates the session in the reverse direction.     Unplanned failures are events such as source system failure or an event on the source system that leads to downtime for production access.     Unplanned failovers are issued from the destination system, and are indicated by setting the is_planned parameter to false. Unplanned failovers provide production access to the original destination resource from a preview synchronized point-in-time snapshot referred to as replication common-base. After an unplanned failover, you can restore the system from any point-in-time snapshots on the new source resource. Unplanned failovers place the original source resource into destination mode once it reestablishes a connection to the source system.  You can use the reprotect action to synchronize the destination storage resource, and then resume the replication session.     After the replication session has failed over, you can resize the volume group or change the volume group membership on the new source resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_failover_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :param ReplicationSessionFailover body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_session_id_failover_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_session_id_failover_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_session_id_failover_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Failover  # noqa: E501

        Fail over a replication session instance of type Asynchronous. Failing over the replication session changes the role of the destination system. After a failover, the original destination system becomes the source system, and production access is enabled for hosts and applications for recovery. Failovers can be planned or unplanned.     Planned failovers are issued from the source system and are indicated by setting the is_planned parameter to true. When you fail over a replication session from the source system, the destination system is fully synchronized with the source to ensure that there is no data loss. During a planned failover, stop I/O operations for any applications and hosts. If a synchronization error occurs during a planned failover, the replication session enters the System_Paused state. You cannot pause a replication session during a planned failover. The following operations can be performed during planned failover: * Unplanned failover * Delete the replication session by removing the protection policy on the storage resource     Failover (planned or unplanned) cannot be performed when a test failover is in progress.     After a planned failover, the replication session is in an inactive state. You can use the reprotect action to synchronize the destination storage resource, and then resume the replication session. The auto-reprotect feature can also be used after a planned failover by using the reverse parameter, which activates the session in the reverse direction.     Unplanned failures are events such as source system failure or an event on the source system that leads to downtime for production access.     Unplanned failovers are issued from the destination system, and are indicated by setting the is_planned parameter to false. Unplanned failovers provide production access to the original destination resource from a preview synchronized point-in-time snapshot referred to as replication common-base. After an unplanned failover, you can restore the system from any point-in-time snapshots on the new source resource. Unplanned failovers place the original source resource into destination mode once it reestablishes a connection to the source system.  You can use the reprotect action to synchronize the destination storage resource, and then resume the replication session.     After the replication session has failed over, you can resize the volume group or change the volume group membership on the new source resource.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_failover_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :param ReplicationSessionFailover body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_session_id_failover_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `replication_session_id_failover_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/replication_session/{id}/failover', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_session_id_get(self, id, **kwargs):  # noqa: E501
        """Instance Query  # noqa: E501

        Query a replication session instance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :return: ReplicationSessionInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_session_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_session_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_session_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Instance Query  # noqa: E501

        Query a replication session instance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :return: ReplicationSessionInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_session_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `replication_session_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/replication_session/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReplicationSessionInstance',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_session_id_pause_post(self, id, **kwargs):  # noqa: E501
        """Pause  # noqa: E501

        Pause a replication session instance. You can pause a replication session for maintenance activities on local or remote system.     The session can be paused when it is in the following states: * OK * Synchronizing * System_Paused * Fractured     In case of loss of network connectivity between two sites, the replication session is paused only on the local system where it is issued. Pause the replication session again to pause both sites. The following operations are not allowed while only the replication session on the local system is paused: * Resume * Sync * Planned Failover     The following operations are allowed while only the replication session on the local system is paused: * Pause - Use to place both sites into the **Paused** state * Failover - Use to get production access from the disaster recovery site * Promote - Use to get production access from local cluster * Demote - Use to remove production access from local cluster * Delete - Delete the replication session     The following system operations may also pause, and subsequently resume, a replication session: * Non-disruptive upgrade * Intra-cluster migration     Leaving replication session in a paused state results in change accumulations on the production mode system. Resuming a replication session that has been paused for a long time can result in long synchronization times.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_pause_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_session_id_pause_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_session_id_pause_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_session_id_pause_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Pause  # noqa: E501

        Pause a replication session instance. You can pause a replication session for maintenance activities on local or remote system.     The session can be paused when it is in the following states: * OK * Synchronizing * System_Paused * Fractured     In case of loss of network connectivity between two sites, the replication session is paused only on the local system where it is issued. Pause the replication session again to pause both sites. The following operations are not allowed while only the replication session on the local system is paused: * Resume * Sync * Planned Failover     The following operations are allowed while only the replication session on the local system is paused: * Pause - Use to place both sites into the **Paused** state * Failover - Use to get production access from the disaster recovery site * Promote - Use to get production access from local cluster * Demote - Use to remove production access from local cluster * Delete - Delete the replication session     The following system operations may also pause, and subsequently resume, a replication session: * Non-disruptive upgrade * Intra-cluster migration     Leaving replication session in a paused state results in change accumulations on the production mode system. Resuming a replication session that has been paused for a long time can result in long synchronization times.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_pause_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_session_id_pause_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `replication_session_id_pause_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/replication_session/{id}/pause', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_session_id_promote_post(self, id, **kwargs):  # noqa: E501
        """Promote replication session  # noqa: E501

        Promote a metro type replication session to enable production access to the resource on the local side of the metro session. The local resource is granted production access independent of its preferred or non-preferred role in the metro relationship. This operation does not change the state of the Metro session. The local_resource_state property on the session instance will indicate that the local side of the metro session was promoted through user action. A snapshot of the local resource will be created before the promote operation. The expiration time of this snapshot will be set to 3 days. This operation can be performed only when the metro session is in the Fractured or Paused states.  Was added in version 3.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_promote_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  Was added in version 3.0.0.0. (required)
        :param ReplicationSessionPromote body: Parameters to promote a replication session.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_session_id_promote_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_session_id_promote_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_session_id_promote_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Promote replication session  # noqa: E501

        Promote a metro type replication session to enable production access to the resource on the local side of the metro session. The local resource is granted production access independent of its preferred or non-preferred role in the metro relationship. This operation does not change the state of the Metro session. The local_resource_state property on the session instance will indicate that the local side of the metro session was promoted through user action. A snapshot of the local resource will be created before the promote operation. The expiration time of this snapshot will be set to 3 days. This operation can be performed only when the metro session is in the Fractured or Paused states.  Was added in version 3.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_promote_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  Was added in version 3.0.0.0. (required)
        :param ReplicationSessionPromote body: Parameters to promote a replication session.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_session_id_promote_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `replication_session_id_promote_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/replication_session/{id}/promote', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_session_id_reprotect_post(self, id, **kwargs):  # noqa: E501
        """Reprotect  # noqa: E501

        Reprotect a replication session instance of type Asynchronous. Activates the replication session and starts synchronization. For session of type Asynchronous, this can only be used when the session has been failed over and from the system that is reported as source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_reprotect_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_session_id_reprotect_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_session_id_reprotect_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_session_id_reprotect_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Reprotect  # noqa: E501

        Reprotect a replication session instance of type Asynchronous. Activates the replication session and starts synchronization. For session of type Asynchronous, this can only be used when the session has been failed over and from the system that is reported as source.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_reprotect_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_session_id_reprotect_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `replication_session_id_reprotect_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/replication_session/{id}/reprotect', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_session_id_resume_post(self, id, **kwargs):  # noqa: E501
        """Resume  # noqa: E501

        Resume a replication session instance that is paused. Resuming the replication session initiates a synchronization cycle if the session was in the following states when the session was paused: * Synchronizing * System_Paused * Fractured     You cannot resume replication sessions paused by the system. The following system operations may also pause, and subsequently resume, a replication session. * Paused_for_NDU * Paused_for_Migration   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_resume_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_session_id_resume_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_session_id_resume_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_session_id_resume_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Resume  # noqa: E501

        Resume a replication session instance that is paused. Resuming the replication session initiates a synchronization cycle if the session was in the following states when the session was paused: * Synchronizing * System_Paused * Fractured     You cannot resume replication sessions paused by the system. The following system operations may also pause, and subsequently resume, a replication session. * Paused_for_NDU * Paused_for_Migration   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_resume_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_session_id_resume_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `replication_session_id_resume_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/replication_session/{id}/resume', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_session_id_start_failover_test_post(self, id, **kwargs):  # noqa: E501
        """Start DR Failover Simulation Test  # noqa: E501

        Start a disaster recovery (DR) failover simulation test at the destination site of a replication session of type Asynchronous to simulate a failover and grant production access to the destination resource. This will enable DR site hosts to access the destination site resource and allow users to test their DR configuration and readiness without interrupting activity at the production site. Replication synchronization activity from the production site will continue to happen while the test is in progress except for the actual synchronization of the destination resource with the primary. Any changes made to the destination resource during the test, including resizing, can be optionally saved in a snapshot at the end of the test, at which point the destination resource will revert to its normal state and role.  Starting of a DR failover simulation test is allowed only at the destination site of a replication session and only when the session is in the following states: * OK * Synchronizing * Paused * System_Paused   This operation is not allowed when a test failover is already in progress on the replication session or if the session is in the following states: * Planned_Failover_In_Progress * DR_Failover_In_Progress * Failed_Over * Paused_For_NDU * Paused_For_Migration   During the test, the following restrictions apply: * Membership changes are not allowed for destination resources that belong to a volume group. * The session cannot be failed over (planned or unplanned).  Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_start_failover_test_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  Was added in version 2.0.0.0. (required)
        :param ReplicationStartFailoverTest body: Parameters to start a DR failover simulation test on a replication session.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_session_id_start_failover_test_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_session_id_start_failover_test_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_session_id_start_failover_test_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Start DR Failover Simulation Test  # noqa: E501

        Start a disaster recovery (DR) failover simulation test at the destination site of a replication session of type Asynchronous to simulate a failover and grant production access to the destination resource. This will enable DR site hosts to access the destination site resource and allow users to test their DR configuration and readiness without interrupting activity at the production site. Replication synchronization activity from the production site will continue to happen while the test is in progress except for the actual synchronization of the destination resource with the primary. Any changes made to the destination resource during the test, including resizing, can be optionally saved in a snapshot at the end of the test, at which point the destination resource will revert to its normal state and role.  Starting of a DR failover simulation test is allowed only at the destination site of a replication session and only when the session is in the following states: * OK * Synchronizing * Paused * System_Paused   This operation is not allowed when a test failover is already in progress on the replication session or if the session is in the following states: * Planned_Failover_In_Progress * DR_Failover_In_Progress * Failed_Over * Paused_For_NDU * Paused_For_Migration   During the test, the following restrictions apply: * Membership changes are not allowed for destination resources that belong to a volume group. * The session cannot be failed over (planned or unplanned).  Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_start_failover_test_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  Was added in version 2.0.0.0. (required)
        :param ReplicationStartFailoverTest body: Parameters to start a DR failover simulation test on a replication session.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_session_id_start_failover_test_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `replication_session_id_start_failover_test_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/replication_session/{id}/start_failover_test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_session_id_stop_failover_test_post(self, id, **kwargs):  # noqa: E501
        """Stop DR Failover Simulation Test  # noqa: E501

        Stop a disaster recovery (DR) failover simulation test that is in progress at the destination site of a replication session of type Asynchronous and revert the destination resource to its normal state and role.  Stopping of a DR failover simulation test is allowed only at the destination site of a replication session and only when a test failover is in progress on the replication session.  Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_stop_failover_test_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  Was added in version 2.0.0.0. (required)
        :param ReplicationStopFailoverTest body: Parameters to stop a DR failover simulation test on a replication session.
        :return: ReplicationSessionStopFailoverTestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_session_id_stop_failover_test_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_session_id_stop_failover_test_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_session_id_stop_failover_test_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Stop DR Failover Simulation Test  # noqa: E501

        Stop a disaster recovery (DR) failover simulation test that is in progress at the destination site of a replication session of type Asynchronous and revert the destination resource to its normal state and role.  Stopping of a DR failover simulation test is allowed only at the destination site of a replication session and only when a test failover is in progress on the replication session.  Was added in version 2.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_stop_failover_test_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  Was added in version 2.0.0.0. (required)
        :param ReplicationStopFailoverTest body: Parameters to stop a DR failover simulation test on a replication session.
        :return: ReplicationSessionStopFailoverTestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_session_id_stop_failover_test_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `replication_session_id_stop_failover_test_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/replication_session/{id}/stop_failover_test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReplicationSessionStopFailoverTestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_session_id_sync_post(self, id, **kwargs):  # noqa: E501
        """Synchronize  # noqa: E501

        Supported for Asynchronous type replication sessions. Synchronize the destination resource with changes on source resource from the previous synchronization cycle.    Also synchronizes any size changes, membership changes, or both, on the source resource. At the end of the synchronization cycle, the destination resource reflects the state as it was when synchronization began. Any size changes, membership changes, or both, to source resource done during the synchronization cycle are replicated in next synchronization cycle.     Synchronization is allowed when the replication session is in the following states: * OK * System_Paused     During synchronization, you can take the following actions: * Planned failover from the source system * Failover from the destination system * Pause replication sessions from the source or destination system * Delete a replication session by removing a protection policy     Synchronization failure places the replication session in a System_Paused state. When the system recovers, the replication session continues from the same point as when the system paused, using the restart address.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_sync_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_session_id_sync_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_session_id_sync_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_session_id_sync_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Synchronize  # noqa: E501

        Supported for Asynchronous type replication sessions. Synchronize the destination resource with changes on source resource from the previous synchronization cycle.    Also synchronizes any size changes, membership changes, or both, on the source resource. At the end of the synchronization cycle, the destination resource reflects the state as it was when synchronization began. Any size changes, membership changes, or both, to source resource done during the synchronization cycle are replicated in next synchronization cycle.     Synchronization is allowed when the replication session is in the following states: * OK * System_Paused     During synchronization, you can take the following actions: * Planned failover from the source system * Failover from the destination system * Pause replication sessions from the source or destination system * Delete a replication session by removing a protection policy     Synchronization failure places the replication session in a System_Paused state. When the system recovers, the replication session continues from the same point as when the system paused, using the restart address.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_session_id_sync_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the replication session.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_session_id_sync_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `replication_session_id_sync_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/replication_session/{id}/sync', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
