# coding: utf-8

"""
    PowerStore REST API

    Storage cluster REST API definition. ( For \"Try It Out\", use the cluster management IP address to load this swaggerui interface. )  # noqa: E501

    OpenAPI spec version: 3.0.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from prime.swagger_client.api_client import ApiClient


class RemoteSystemApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def remote_system_get(self, **kwargs):  # noqa: E501
        """Collection Query  # noqa: E501

        Query remote systems.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[RemoteSystemInstance]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remote_system_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remote_system_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def remote_system_get_with_http_info(self, **kwargs):  # noqa: E501
        """Collection Query  # noqa: E501

        Query remote systems.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[RemoteSystemInstance]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remote_system_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/remote_system', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RemoteSystemInstance]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remote_system_id_delete(self, id, **kwargs):  # noqa: E501
        """Delete  # noqa: E501

        Delete a remote system. Deleting the remote system deletes the management and data connections established with the remote system. You cannot delete a remote system if there are active import sessions, or if there are remote protection policies active in the system referencing the remote system instance.     For PowerStore remote systems, the relationship is deleted in both directions if the remote system is up and connectable. You cannot delete a PowerStore remote system if there is no management connectivity between the local and remore systems. Only the local end of the relationship is deleted. Manually log in to the remote PowerStore system and remove the relationship.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_id_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the remote system.  name:{name} can be used instead of {id}. (required)
        :param RemoteSystemDelete body: Parameters to delete a remote system. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remote_system_id_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.remote_system_id_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def remote_system_id_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete  # noqa: E501

        Delete a remote system. Deleting the remote system deletes the management and data connections established with the remote system. You cannot delete a remote system if there are active import sessions, or if there are remote protection policies active in the system referencing the remote system instance.     For PowerStore remote systems, the relationship is deleted in both directions if the remote system is up and connectable. You cannot delete a PowerStore remote system if there is no management connectivity between the local and remore systems. Only the local end of the relationship is deleted. Manually log in to the remote PowerStore system and remove the relationship.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_id_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the remote system.  name:{name} can be used instead of {id}. (required)
        :param RemoteSystemDelete body: Parameters to delete a remote system. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remote_system_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `remote_system_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/remote_system/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remote_system_id_discover_post(self, id, **kwargs):  # noqa: E501
        """Discover  # noqa: E501

        Discover the importable resources such as volumes, consistency groups, file systems  and snapshot schedules from the remote system. This api is not applicable for PowerStore and cloud type remote systems. For VNX remote system it discovers both block and file resources together if it have both file and block import capabilities.  Was added in version 3.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_id_discover_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the remote system.  name:{name} can be used instead of {id}. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remote_system_id_discover_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.remote_system_id_discover_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def remote_system_id_discover_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Discover  # noqa: E501

        Discover the importable resources such as volumes, consistency groups, file systems  and snapshot schedules from the remote system. This api is not applicable for PowerStore and cloud type remote systems. For VNX remote system it discovers both block and file resources together if it have both file and block import capabilities.  Was added in version 3.0.0.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_id_discover_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the remote system.  name:{name} can be used instead of {id}. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remote_system_id_discover_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `remote_system_id_discover_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/remote_system/{id}/discover', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remote_system_id_get(self, id, **kwargs):  # noqa: E501
        """Instance Query  # noqa: E501

        Query a remote system instance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the remote system.  name:{name} can be used instead of {id}. (required)
        :return: RemoteSystemInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remote_system_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.remote_system_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def remote_system_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Instance Query  # noqa: E501

        Query a remote system instance.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the remote system.  name:{name} can be used instead of {id}. (required)
        :return: RemoteSystemInstance
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remote_system_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `remote_system_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/remote_system/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RemoteSystemInstance',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remote_system_id_patch(self, id, body, **kwargs):  # noqa: E501
        """Modify  # noqa: E501

        Modify a remote system instance. The list of valid parameters depends on the type of remote system. For PowerStore remote system relationships: * Description * Management address - An IPv4 or IPv6 address or FQDN.  For non-PowerStore remote system relationships: * Name * Description * Management address - An IPv4 address or FQDN. * Remote administrator credentials For VNX remote system relationships, file properties such as file_connection_address, vnx_username and password can be provided during modify if it not exists already: * Description * Management address - An IPv4 address. FQDN is not supported. * Remote administrator credentials * File connection address - Control station IPv4 or IPv6 address of the VNX. * NAS admin username * NAS admin password For a PowerMax/VMAX remote system, the attributes that can be modified are * Description * Management address - An IPv4 address. FQDN is not supported. * Remote administrator credentials * Management Port After modifying the remote session instance, the system reestablishes the data connections as needed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_id_patch(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the remote system.  name:{name} can be used instead of {id}. (required)
        :param RemoteSystemModify body: Parameters to modify the remote system.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remote_system_id_patch_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.remote_system_id_patch_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def remote_system_id_patch_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Modify  # noqa: E501

        Modify a remote system instance. The list of valid parameters depends on the type of remote system. For PowerStore remote system relationships: * Description * Management address - An IPv4 or IPv6 address or FQDN.  For non-PowerStore remote system relationships: * Name * Description * Management address - An IPv4 address or FQDN. * Remote administrator credentials For VNX remote system relationships, file properties such as file_connection_address, vnx_username and password can be provided during modify if it not exists already: * Description * Management address - An IPv4 address. FQDN is not supported. * Remote administrator credentials * File connection address - Control station IPv4 or IPv6 address of the VNX. * NAS admin username * NAS admin password For a PowerMax/VMAX remote system, the attributes that can be modified are * Description * Management address - An IPv4 address. FQDN is not supported. * Remote administrator credentials * Management Port After modifying the remote session instance, the system reestablishes the data connections as needed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_id_patch_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the remote system.  name:{name} can be used instead of {id}. (required)
        :param RemoteSystemModify body: Parameters to modify the remote system.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remote_system_id_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `remote_system_id_patch`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `remote_system_id_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/remote_system/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remote_system_id_verify_post(self, id, **kwargs):  # noqa: E501
        """Verify  # noqa: E501

        Verify and update the remote system instance.     Detects changes in the local and remote systems and reestablishes data connections, also taking the Challenge Handshake Authentication Protocol (CHAP) settings into account for iSCSI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_id_verify_post(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the remote system.  name:{name} can be used instead of {id}. (required)
        :param RemoteSystemVerify body: Parameters to verify a remote system. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remote_system_id_verify_post_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.remote_system_id_verify_post_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def remote_system_id_verify_post_with_http_info(self, id, **kwargs):  # noqa: E501
        """Verify  # noqa: E501

        Verify and update the remote system instance.     Detects changes in the local and remote systems and reestablishes data connections, also taking the Challenge Handshake Authentication Protocol (CHAP) settings into account for iSCSI.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_id_verify_post_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Unique identifier of the remote system.  name:{name} can be used instead of {id}. (required)
        :param RemoteSystemVerify body: Parameters to verify a remote system. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remote_system_id_verify_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in params or
                                                       params['id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `id` when calling `remote_system_id_verify_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/remote_system/{id}/verify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remote_system_post(self, body, **kwargs):  # noqa: E501
        """Create  # noqa: E501

        Create a new remote system relationship. The type of remote system being connected requires different parameter sets. For PowerStore remote system relationships, include the following parameters: * Management address - Either an IPv4 or IPv6 address or FQDN. * Type of remote system * Data network latency type PowerStore remote system will support Unified (Block and File) by default. For PowerStore remote system relationships, the relationship is created in both directions. Remote protection policies can be configured using the PowerStore remote system instance on either of the systems. This enables remote replication for storage resources in either direction. The data connections take into account whether Challenge Handshake Authentication Protocol (CHAP) is enabled on local and remote PowerStore systems. The PowerStore local system can establish a block import relationship with PS_Equalogic, Unity, Storage_Center, XtremeIO, NetApp, PowerMax/VMAX and VNX . For VNX both block and file import are supported. Unity, Storage_Center, XtremeIO, VNX remote system can be created with data connection type as iSCSI or FC.PS_Equalogic and NetApp can be created with data connection type as iSCSI only.PowerMax/VMAX can be created with data connection type as FC only. For VNX, Unity, PS_Equallogic , Storage_Center, XtremeIO, NetApp remote system relationships with iSCSI as backend connectivity, include the following parameters: * Management address - Either an IPv4 or IPv6 address or FQDN. * Type of remote system * Name * Description * Remote administrator credentials * iSCSI address - IPv4 address * CHAP mode for discovery or session * CHAP secrets details For VNX, Unity, Storage_Center, XtremeIO, PowerMax/VMAX remote system relationships with FC as backend connectivity, include the following parameters: * Management address - Either an IPv4 or IPv6 address or FQDN. * Type of remote system * Name * Description * Remote administrator credentials * Data Connection Type - FC * Management Port - Management port is applicable only for PowerMax/VMAX remote system.  For VNX remote system relationships for file import, include the following parameters along with above block parameters for both block and file import or only below file parameters for File import only cases: * File connection address - Control station IPv4 or IPv6 address of the VNX. * Type of remote system * NAS admin username * NAS admin password * Name * Description Based on the input parameters and the type of remote system, the system will automatically determine the capabilities for  remote systems. Remote Systems storage capabilities currently supported are: * Powerstore - Asynchronous_Block_Replication, Asynchronous_File_Replication, Asynchronous_Vvol_Replication * Unity - Block_Nondisruptive_Import, Block_Agentless_Import * VNX - Block_Nondisruptive_Import, Block_Agentless_Import, File_Import * PS_Equallogic - Block_Nondisruptive_Import, Block_Agentless_Import * Storage_Center - Block_Nondisruptive_Import, Block_Agentless_Import * XtremIO - Block_Agentless_Import * NetApp - Block_Agentless_Import * PowerMax/VMAX - Block_Agentless_Import  After the remote system relationship is created, the local system can communicate with the remote system, and open data connections for data transfer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RemoteSystemCreate body: Parameters to create a remote system.  (required)
        :return: CreateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remote_system_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.remote_system_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def remote_system_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create  # noqa: E501

        Create a new remote system relationship. The type of remote system being connected requires different parameter sets. For PowerStore remote system relationships, include the following parameters: * Management address - Either an IPv4 or IPv6 address or FQDN. * Type of remote system * Data network latency type PowerStore remote system will support Unified (Block and File) by default. For PowerStore remote system relationships, the relationship is created in both directions. Remote protection policies can be configured using the PowerStore remote system instance on either of the systems. This enables remote replication for storage resources in either direction. The data connections take into account whether Challenge Handshake Authentication Protocol (CHAP) is enabled on local and remote PowerStore systems. The PowerStore local system can establish a block import relationship with PS_Equalogic, Unity, Storage_Center, XtremeIO, NetApp, PowerMax/VMAX and VNX . For VNX both block and file import are supported. Unity, Storage_Center, XtremeIO, VNX remote system can be created with data connection type as iSCSI or FC.PS_Equalogic and NetApp can be created with data connection type as iSCSI only.PowerMax/VMAX can be created with data connection type as FC only. For VNX, Unity, PS_Equallogic , Storage_Center, XtremeIO, NetApp remote system relationships with iSCSI as backend connectivity, include the following parameters: * Management address - Either an IPv4 or IPv6 address or FQDN. * Type of remote system * Name * Description * Remote administrator credentials * iSCSI address - IPv4 address * CHAP mode for discovery or session * CHAP secrets details For VNX, Unity, Storage_Center, XtremeIO, PowerMax/VMAX remote system relationships with FC as backend connectivity, include the following parameters: * Management address - Either an IPv4 or IPv6 address or FQDN. * Type of remote system * Name * Description * Remote administrator credentials * Data Connection Type - FC * Management Port - Management port is applicable only for PowerMax/VMAX remote system.  For VNX remote system relationships for file import, include the following parameters along with above block parameters for both block and file import or only below file parameters for File import only cases: * File connection address - Control station IPv4 or IPv6 address of the VNX. * Type of remote system * NAS admin username * NAS admin password * Name * Description Based on the input parameters and the type of remote system, the system will automatically determine the capabilities for  remote systems. Remote Systems storage capabilities currently supported are: * Powerstore - Asynchronous_Block_Replication, Asynchronous_File_Replication, Asynchronous_Vvol_Replication * Unity - Block_Nondisruptive_Import, Block_Agentless_Import * VNX - Block_Nondisruptive_Import, Block_Agentless_Import, File_Import * PS_Equallogic - Block_Nondisruptive_Import, Block_Agentless_Import * Storage_Center - Block_Nondisruptive_Import, Block_Agentless_Import * XtremIO - Block_Agentless_Import * NetApp - Block_Agentless_Import * PowerMax/VMAX - Block_Agentless_Import  After the remote system relationship is created, the local system can communicate with the remote system, and open data connections for data transfer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remote_system_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RemoteSystemCreate body: Parameters to create a remote system.  (required)
        :return: CreateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remote_system_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in params or
                                                       params['body'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `body` when calling `remote_system_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/remote_system', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
